grammar hu.bme.mit.inf.ttmc.statechart.language.StatechartLanguage with hu.bme.mit.inf.ttmc.constraint.language.ConstraintLanguage

import "http://www.inf.mit.bme.hu/ttmc/statechart/Model" 
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore
import "http://www.inf.mit.bme.hu/ttmc/constraint/Model" as ConstraintModel

StatechartSpecification returns StatechartSpecification:
	'specification' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? '{'
	(
		typeDeclarations+=TypeDeclaration |
		constantDeclarations+=ConstantDeclaration |
		functionDeclarations+=FunctionDeclaration |
		basicConstraintDefinitions+=BasicConstraintDefinition |
		signalDeclarations+=SignalDeclaration |
		statechartDeclarations+=StatechartDeclaration
	)*
	'}'
;

VariableDeclaration returns VariableDeclaration:
	'var' name=ID ':' type=Type (':=' expression=Expression)?
;


TimeoutDeclaration returns TimeoutDeclaration:
	'timeout' name=ID
;

SignalDeclaration returns SignalDeclaration:
	'signal' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')?
;

Event:
	DefaultEvent |
	SignalEvent |
	TimeoutEvent
;

DefaultEvent returns DefaultEvent:
	{DefaultEvent} 'by' 'default'
;

SignalEvent:
	'upon' signalDeclaration=[SignalDeclaration] ('(' (parameters+=Expression)(',' parameters+=Expression)* ')')?
;

TimeoutEvent:
	'when' timeoutDeclaration=[TimeoutDeclaration]
;

Action:
	SignalAction |
	SetTimeoutAction |
	DeactivateTimeoutAction |
	AssignmentAction
;

SignalAction returns SignalAction:
	'send' signalDeclaration=[SignalDeclaration] ('(' (parameters+=Expression)(',' parameters+=Expression)* ')')?
;

SetTimeoutAction returns SetTimeoutAction:
	'set' timeoutDeclaration=[TimeoutDeclaration] ':=' time=Expression
;

DeactivateTimeoutAction returns DeactivateTimeoutAction:
	'deactivate' timeoutDeclaration=[TimeoutDeclaration]
;


AssignmentAction returns AssignmentAction:
	'assign' lhs=Expression ':=' rhs=Expression
;

StatechartDeclaration returns StatechartDeclaration:
	'statechart' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? ':='
    statechart=Statechart
;

Statechart returns Statechart:
	StatechartDefinition |
	StatechartReference
;

StatechartDefinition returns StatechartDefinition:
	{StatechartDefinition} '{'
		(
			variableDeclarations+=VariableDeclaration |
			timeoutDeclarations+=TimeoutDeclaration
		)*
		(region=Region)?
	'}'
;

StatechartReference returns StatechartReference:
	{StatechartReference} reference=[StatechartDeclaration] ('(' ((parameters+=Expression)(',' parameters+=Expression)*)? ')')?
;

Region returns Region:
	'region' name=ID '{'
		(
			(stateNodes+=StateNode) |
			(transitions+=Transition)
		)*
	'}'
;

Transition returns Transition:
	'transition'
	('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')?
	'from' sourceState=[StateNode] 'to' targetState=[StateNode]
	(
		(trigger+=Event)?
		('[' guard=Expression ']')?
		('/' (effects+=Action) (';' effects+=Action)*)?
	)
;

StateNode returns StateNode:
	State |
	PseudoState
;

State returns State:
	'state' name=ID
	(
		'{'
		(
			(
				('invariant' invariants+=Expression)*
				('entry' '/' (entryActions+=Action)(';' entryActions+=Action)* )?
				('exit' '/' (exitActions+=Action)(';' exitActions+=Action)* )?
			)
			(regions+=Region)*
		)
		'}'
	)?
;

PseudoState returns PseudoState:
	InitialState |
	ForkState |
	JoinState |
	ChoiceState |
	MergeState
;

MergeState returns MergeState:
	'merge' name=ID
;

ChoiceState returns ChoiceState:
	'choice' name=ID
;

JoinState returns JoinState:
	'join' name=ID
;

ForkState returns ForkState:
	'fork' name=ID
;

InitialState returns InitialState:
	'initial' name=ID
;