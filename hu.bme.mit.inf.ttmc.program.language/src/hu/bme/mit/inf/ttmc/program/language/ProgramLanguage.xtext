grammar hu.bme.mit.inf.ttmc.program.language.ProgramLanguage with hu.bme.mit.inf.ttmc.constraint.language.ConstraintLanguage

import "http://www.inf.mit.bme.hu/ttmc/program/Model" 
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore
import "http://www.inf.mit.bme.hu/ttmc/constraint/Model" as ConstraintModel


ProgramSpecification returns ProgramSpecification:
	'specification' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? '{'
		(
			typeDeclarations+=TypeDeclaration |
			functionDeclarations+=FunctionDeclaration |
			constantDeclarations+=ConstantDeclaration |
			basicConstraintDefinitions+=BasicConstraintDefinition |
			procedureDeclarations+=ProcedureDeclaration
		)*
	'}'
;

/*
 * Restrictions and extensions
 */
 
 Expression returns ConstraintModel::Expression:
 	WithExpression
 ;
 
 //prefix unary, right-associative
UnaryLogicExpression returns ConstraintModel::Expression:
	NotExpression |
	ForallExpression |
	ExistsExpression |
	FunctionLiteralExpression |
	//
	ProcedureLiteralExpression |
	
	LetExpression |
	
	InExpression
;

ProcedureLiteralExpression returns ProcedureLiteralExpression:
	{ProcedureLiteralExpression} => 'procedure' '(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')' ':' returnType=Type statement=BlockStatement
	
;

PrimaryExpression returns ConstraintModel::Expression:
	LiteralExpression | ReferenceExpression  | ResultExpression | '(' Expression ')'
;

ResultExpression returns ResultExpression:
	{ResultExpression} 'result'
;

TypeDefinition returns ConstraintModel::TypeDefinition:
	NaturalTypeDefinition |
	IntegerTypeDefinition |
	BooleanTypeDefinition |
	RealTypeDefinition |
	ArrayTypeDefinition |
	EnumerationTypeDefinition |
	RecordTypeDefinition |
	TupleTypeDefinition |
	SubrangeTypeDefinition |
	SubTypeDefinition |
	FunctionTypeDefinition |
	
	ProcedureTypeDefinition |
	UnitTypeDefinition
;

ProcedureTypeDefinition returns ProcedureTypeDefinition:
	'procedure' '(' ((parameterTypes+=Type)(',' parameterTypes+=Type)*)? ')' ':' returnType=Type
;

UnitTypeDefinition returns UnitTypeDefinition:
	{UnitTypeDefinition} 'unit'
;

/////

PreconditionAnnotation returns PreconditionAnnotation:
	'@pre' expression=Expression
;

PostconditionAnnotation returns PostconditionAnnotation:
	'@post' expression=Expression
;

LoopAnnotation returns LoopAnnotation:
	'@loop' expression=Expression
;

/////

ProcedureDeclaration returns ProcedureDeclaration:
	(
		preconditionAnnotations+=PreconditionAnnotation |
		postconditionAnnotations+=PostconditionAnnotation
	)*
	'procedure' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? ':' type=Type (statement=BlockStatement)?
;


VariableDeclaration returns VariableDeclaration:
	'var' name=ID ':' type=Type (':=' expression=Expression)? ';'
;

Statement returns Statement:
	BlockStatement | WhileStatement | DoStatement | IfStatement | AssignmentStatement | ReturnStatement | HavocStatement | AssumeStatement | AssertStatement | SkipStatement
;

BlockStatement returns BlockStatement:
	{BlockStatement} '{'
		(variableDeclarations+=VariableDeclaration)*
		(statements+=Statement)*
	'}'
;

IfStatement returns IfStatement:
	'if' ('*' | conditionExpression=Expression) 'then' thenStatement=Statement (=> 'else' elseStatement=Statement)?
;

WhileStatement returns WhileStatement:
	(loopAnnotations+=LoopAnnotation)*
	'while' ('*' | conditionExpression=Expression) 'do' doStatement=Statement
;

DoStatement returns DoStatement:
//	(loopAnnotations+=LoopAnnotation)*
	'do' doStatement=Statement 'while' ('*' | conditionExpression=Expression) ';'
;

AssignmentStatement returns AssignmentStatement:
	lhsExpression=Expression ':=' rhsExpression=Expression ';'
;

ReturnStatement returns ReturnStatement:
	'return' expression=Expression ';'
;

HavocStatement returns HavocStatement:
	'havoc' expression=Expression ';'
;

AssumeStatement returns AssumeStatement:
	'assume' expression=Expression ';'
;

AssertStatement returns AssertStatement:
	'assert' expression=Expression ';'
;

SkipStatement returns SkipStatement:
	{SkipStatement} 'skip' ';'
;
