// automatically generated by Xtext
grammar hu.bme.mit.inf.theta.system.language.SystemLanguage with hu.bme.mit.inf.theta.constraint.language.ConstraintLanguage

import "http://www.inf.mit.bme.hu/theta/system/Model" 
import "http://www.inf.mit.bme.hu/theta/constraint/Model" as ConstraintModel
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore


SystemSpecification returns SystemSpecification:
	'specification' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? '{'
		(
			typeDeclarations+=TypeDeclaration |
			functionDeclarations+=FunctionDeclaration |
			constantDeclarations+=ConstantDeclaration |
			basicConstraintDefinitions+=BasicConstraintDefinition |
			systemDeclarations+=SystemDeclaration |
			propertyDeclarations+=PropertyDeclaration
		)*
	'}'
;


// Temporal operators

//multiary
AndExpression returns ConstraintModel::Expression:
	ReleaseExpression ({ConstraintModel::AndExpression.operands+=current} ('and' operands+=ReleaseExpression)+)?
;

//binary, left-associative
ReleaseExpression returns ConstraintModel::Expression:
	UntilExpression ({ReleaseExpression.leftOperand=current} 'R' rightOperand=UntilExpression)*
;

//binary, left-associative
UntilExpression returns ConstraintModel::Expression:
	UnaryLogicExpression ({UntilExpression.leftOperand=current} 'U' rightOperand=UnaryLogicExpression)*
;

//prefix unary, right-associative
UnaryLogicExpression returns ConstraintModel::Expression:
	NotExpression |
	ForallExpression |
	ExistsExpression |
	FunctionLiteralExpression |
	
	GloballyExpression |
	FinallyExpression |
	NextExpression |
	TemporalForallExpression |
	TemporalExistsExpression |
	
	LetExpression |
	
	InExpression
;

GloballyExpression returns ConstraintModel::Expression:
	{GloballyExpression} => 'G' operand=UnaryLogicExpression
;

FinallyExpression returns ConstraintModel::Expression:
	{FinallyExpression} => 'F' operand=UnaryLogicExpression
;

NextExpression returns ConstraintModel::Expression:
	{NextExpression} => 'X' operand=UnaryLogicExpression
;

TemporalForallExpression returns ConstraintModel::Expression:
	{TemporalForallExpression} => 'A' operand=UnaryLogicExpression
;

TemporalExistsExpression returns ConstraintModel::Expression:
	{TemporalExistsExpression} => 'E' operand=UnaryLogicExpression
;

//binary (postfix unary), left-associative
AccessExpression returns ConstraintModel::Expression:
	PrimaryExpression (
		{ConstraintModel::ArrayAccessExpression.operand=current} '[' ((parameters+=Expression)(',' parameters+=Expression)*) ']' |
		{ConstraintModel::FunctionAccessExpression.operand=current} '(' ((parameters+=Expression)(',' parameters+=Expression)*) ')' |
		{ConstraintModel::RecordAccessExpression.operand=current} '.' field=ID |
		{ConstraintModel::TupleAccessExpression.operand=current} '!' index=INTEGER |
		
		{PrimedExpression.operand=current} "'"
	)*
;

////


SystemDeclaration returns SystemDeclaration:
	'system' name=ID ('(' ((parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)*)? ')')? ':=' system=System
;

System returns System:
	AsynchronousCompositeSystem
;


AsynchronousCompositeSystem returns System:
	SynchronousCompositeSystem ({AsynchronousCompositeSystem.leftSystem=current} '[]' rightSystem=SynchronousCompositeSystem)*
;

SynchronousCompositeSystem returns System:
	MultiSystem ({SynchronousCompositeSystem.leftSystem=current} '||' rightSystem=MultiSystem)*
;

MultiSystem returns System:
	SynchronousMultiSystem |
	AsynchronousMultiSystem |
	PrimarySystem
;

SynchronousMultiSystem returns System:
	{SynchronousMultiSystem} => 'sync' '(' (parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)* ')' ':' system=MultiSystem
;

AsynchronousMultiSystem returns System:
	{AsynchronousMultiSystem} => 'async' '(' (parameterDeclarations+=ParameterDeclaration)(',' parameterDeclarations+=ParameterDeclaration)* ')' ':' system=MultiSystem
;

PrimarySystem returns System:
	SystemReference | SystemDefinition | '(' System ')'
;

SystemReference returns System:
	{SystemReference} reference=[SystemDeclaration] ('(' ((parameters+=Expression)(',' parameters+=Expression)*)? ')')?
;

SystemDefinition returns System:
	{SystemDefinition} '{'
		(
			variableDeclarations+=VariableDeclaration |
			definitionDeclarations+=DefinitionDeclaration |
			systemConstraintDefinitions+=SystemConstraintDefinition
		)*
	'}'
;

DefinitionDeclaration returns DefinitionDeclaration:
	'definition' name=ID ':' type=Type ':=' expression=Expression
;

VariableDeclaration returns VariableDeclaration:
	'var' name=ID ':' type=Type
;

SystemConstraintDefinition returns SystemConstraintDefinition:
	InvariantConstraintDefinition | InitialConstraintDefinition | TransitionConstraintDefinition
;

InvariantConstraintDefinition returns InvariantConstraintDefinition:
	'invariant' expression=Expression
;

InitialConstraintDefinition returns InitialConstraintDefinition:
	'initial' expression=Expression
;

TransitionConstraintDefinition returns TransitionConstraintDefinition:
	'transition' expression=Expression
;

PropertyDeclaration returns PropertyDeclaration:
	'property' name=ID ':' system=System 'models' expression=Expression
;