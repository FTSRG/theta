specification MutualExclusion_check {

	property safe: {
		// delay
		var d : real
		
		// normal variables
		var lock : integer
		var location1 : integer
		var location2 : integer
				
		// clock variables
		var c1 : real
		var c2 : real
		
		// type invariants
		invariant lock >= 0
		invariant lock <= 2
		invariant location1 >= 0
		invariant location1 <= 3
		invariant location2 >= 0
		invariant location2 <= 3
		invariant c1 >= 0%1
		invariant c2 >= 0%1
		invariant d >= 0%1
		
		// normal invariants
		invariant location1 = 1 imply c1 + d <= 2%1
		invariant location2 = 1 imply c2 + d <= 2%1
		
		initial lock = 0
		initial location1 = 0
		initial location2 = 0
		initial c1 = 0%1
		initial c2 = 0%1

		transition (
			location1 = 0 and
			lock = 0 and
			lock' = lock and
			location1' = 1 and
			location2' = location2 and
			c1' = 0%1 and
			c2' = c2 + d
		) or (
			location1 = 1 and
			c1 + d <= 2%1 and
			lock' = 1 and
			location1' = 2 and
			location2' = location2 and
			c1' = 0%1 and
			c2' = c2 + d
		) or (
			location1 = 2 and
			c1 + d >= 1%1 and
			lock /= 1 and
			lock' = lock and
			location1' = 0 and
			location2' = location2 and
			c1' = c1 + d and
			c2' = c2 + d
		) or (
			location1 = 2 and
			c1 + d >= 1%1 and
			lock = 1 and
			lock' = lock and
			location1' = 3 and
			location2' = location2 and
			c1' = c1 + d and
			c2' = c2 + d
		) or (			
			location1 = 3 and
			lock' = 0 and
			location1' = 0 and
			location2' = location2 and
			c1' = c1 + d and
			c2' = c2 + d
		) or (
			location2 = 0 and
			lock = 0 and
			lock' = lock and
			location1' = location1 and
			location2' = 1 and
			c1' = c1 + d and
			c2' = 0%1
		) or (
			location2 = 1 and
			c2 + d <= 2%1 and
			lock' = 2 and
			location1' = location1 and
			location2' = 2 and
			c1' = c1 + d and
			c2' = 0%1
		) or (
			location2 = 2 and
			c2 + d >= 1%1 and
			lock /= 2 and
			lock' = lock and
			location1' = location1 and
			location2' = 0 and
			c1' = c1 + d and
			c2' = c2 + d
		) or (
			location2 = 2 and
			c2 + d >= 1%1 and
			lock = 2 and
			lock' = lock and
			location1' = location1 and
			location2' = 3 and
			c1' = c1 + d and
			c2' = c2 + d
		) or (
			location2 = 3 and
			lock' = 0 and
			location1' = location1 and
			location2' = 0 and
			c1' = c1 + d and
			c2' = c2 + d
		)
	} models 
		G(location1 /= 3 or location2 /= 3)
}